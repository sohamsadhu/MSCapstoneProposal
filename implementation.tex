\chapter{Research Approach and Methodology}

\section{Experiment Structure}

The experiment is designed to find the number of attempts it takes to find near collision amongst the three
candidate hashing algorithm BLAKE, Keccak and Gr{\o}stl when subjected to attacks from following algorithms
hill climbing, simulated annealing, tabu search and random selection. The idea is to take a seed message and
update it, so we get two different input message with tiny difference. Then try to minimize our cost function,
which is minimizing the hamming weight of the string obtained by bitwise XOR of the two message digests, 
obtained by feeding the two input message that are padded by the same chaining value. The minimization of the
of the cost function is obtained by the collision finding the algorithm, which they acheive by selecting
the suitable chaining value.

The experiment is conducted for a number of trials, where the digest lengths are varied at the standard bit
lengths of 224, 256, 384 and 512 as standardized by SHA-3. The full version of SHA-3 finalist hashing algorithms
have been found to be practically secure, so we do the experiments on the reduced versions of these algorithms.
A hashing algorithm can be reduced in ways like reducing the digest size, the internal state size, or the
number of permutation rounds. We choose vary the permutation rounds in the hash functions for our experiment.

\subsection{Input}

The string "The quick brown fox jumps over the lazy dog", was chosen as the root seed message. This seed string
contains all letters from English alphabet, and is neither too small or large. Pairs were made from this seed
string, by toggling a bit, from the ASCII/UTF-8 bit representation of this string. The toggling of the bits are
divided into 3 parts - starting, middle, and end. In starting part the most significant bits of the string are
toggled, while in the end part the least significant bits are toggled. In the middle part, the bits toggled 
equally from the most significant and least significant side of the bit that is in middle of the string. For
example let bit representation of a string be $01100010 00011000$, then in starting section there will be strings
generated of kind ${\bf 1}1100010 00011000$, $0{\bf 0}100010 00011000$, $01{\bf 0}00010 00011000$ and so on. 
Only 1 bit from the seed string is toggled, starting from the first bit, then the second bit. This process is
repeated till the number of bits asked to be toggled. In this case of experiment we updated 20 bits from the
seed string, thus generating 20 strings from seed string each having a bit difference from the seed.

The generated strings are paired up with the seed string and are written to a file. Each file has a pair of
strings written to it, separated by newline. The text files holding these pairs are named the number, derived
from the order in which the bit was updated for the generated string. For example the input file 1.txt will
have the entry of seed string and the generated string that has the first bit toggled. Following are the
contents of the file 1.txt in our case.

\begin{center}54686520717569636b2062726f776e20666f78206a756d7073206f76657220746865206c617a7920646f67
d4686520717569636b2062726f776e20666f78206a756d7073206f76657220746865206c617a7920646f67\end{center}

Notice that the first line is the hexadecimal representation of the seed string "The quick brown fox jumps over
the lazy dog", and the second line has the first bit toggled, from the seed string and again represented in
hexadecimal format. In similar way rest of the 20 files are created and named for the bits updated from the most 
significant bit onwards. These files are then stored in the folder "Start", which in turn is stored in the folder 
called "Input" that holds all the input strings.

Similarly in the "Input" folder two more folders "Middle" and "End" are created, and each filled with 20 text
files named or numbered 1 to 20. In the "Middle" folder are files that have two lines of string that have one
bit difference in the middle section of the string. The bits updated are equally distributed around most and least
significant between the middle bit in the seed string. For example in case of two bits being toggled, for the 
"Middle" section for seed string in bit form $01100010 00011000$ you will get two strings like $0110001{\bf 1}
00011000$, and $01100010 {\bf 1}0011000$. The bit toggling starts from the most significant bit selected from 
the middle bit to least significant bit, that is from left to right. So in the example provided if the seed string
is $01100010 00011000$, then file Input/Middle/1.txt will contain 

\begin{center}$01100010 00011000$

$0110001{\bf 1} 00011000$\end{center}

an file Input/Middle/2.txt will contain.

\begin{center}$01100010 00011000$

$01100010 {\bf 1}0011000$\end{center}

Please note that the above mentioned fragments are examples, and not actual contents. The actual contents are going
to be hexadecimal representation of bit value, of the seed string "The quick brown fox jumps over the lazy dog", and 
the hexadecimal representation of bits of the updated string, as shown for the file 1.txt in "Start" folder category.

In the similar manner, files are created for the "End" category. Least significant bits are toggled, one by one
proceeding towards the significant bits. Say the seed string is $01100010 00011000$ then in file 1.txt the seed will
be paired with string $01100010 0001100{\bf 1}$, and in file 2.txt it will be paired with $01100010 000110{\bf 1}0$
and so on.

\subsection{Output}

The output has detailed folder structure, due to breadth of the experiment parameters and numbers noted down for
the same. It has the following structure
\begin{center}Output/length\_of\_chain\_value/collision\_algorithm/digest\_size/SHA3\_finalist\_algorithm
/number\_of\_rounds/Category\_of\_toggled\_input/files\_named\_as\_in\_input\end{center}

For example if the experiment is conducted on input 1.txt on Input/Start category, with a chaining value length of 
32 bits. The collision algorithm Hill Climbing in ran on SHA-3 finalist algorithm BLAKE, that hashes both the input 
strings concatenated with the chaining value for a digest size of 224 bits, running only 2 rounds of permutation.
Then the output file 1.txt is created in the location as per the above given structure in path 
Output/32/HillClimbing/224/BLAKE/2/Start/1.txt.

Each file has 8 entries in it, which are 
\begin{enumerate}
\item The number of times near collisions were found and not found, from the number of trials.
\item The cumulative total number of iterations that it took for the algorithm to find the near collision.
\item The cumulative total number of iterations ran, from the trials when it did not find near collision.
\item Average number of iterations for when near collisions were found and not found.
\item Total cumulative iterations altogether for the experiment for all trials, and average iterations.
\end{enumerate}

\subsection{Rational for the experiment structure and parameters}

\subsection{Collection of result data}

\section{Implementation}

\subsection{Input Creation}

\subsection{Hash function implementation}

\subsection{Experiment with different collision methods}

\subsection{Testing the implemented code}
