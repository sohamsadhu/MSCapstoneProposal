\chapter{Hypothesis based on Hill Climbing to find near collisions}

%% Obviously you need to delete these lines when you have written up your text
%\begin{itemize}
%\item{} How you designed your solution
%\item{} Rationale for decisions
%\item{} Compare and contrast design with other approaches (related work) 
%\end{itemize}

\section{Finding near collisions with Hill Climbing}

A generic algorithm applied to find collisions, in reduced rounds of some SHA-3 competitors was Hill Climbing
\cite{00029}. Near collisions in which more than 75\% of the bits were same for two different messages, were found 
for reduced rounds of BLAKE-32, Hamsi-256 and JH. Near collision results are important for knowing the security
margins. In some cases, output of hash functions may be truncated for compatibility or efficiency purposes. In 
such cases near collisions could be improved to obtain collisions.

A $\epsilon / n $ bit near collision for hash function h and two messages $M_{1}$ and $M_{2}$, where $M_{1} \neq M_{2}$ can be 
defined as

$HW( h( M_{1}, CV ) \oplus h( M_{2}, CV ) ) = n - \epsilon $

where HW is the Hamming weight, and CV is the chaining value, and n is the hash size in bits.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ | c | c | } \hline
      $\epsilon / n $                         & Complexity $( \approx )$ \\ \hline
      128 / 256, 256 / 512, 512 / 1024 & $2^{4}$ \\ \hline
      151 / 256, 287 / 512, 553 / 1024 & $2^{10}$ \\ \hline
      166 / 256, 308 / 512, 585 / 1024 & $2^{20}$ \\ \hline
      176 / 256, 323 / 512, 606 / 1024 & $2^{30}$ \\ \hline
      184 / 256, 335 / 512, 623 / 1024 & $2^{40}$ \\ \hline
      191 / 256, 345 / 512, 638 / 1024 & $2^{50}$ \\ \hline
      197 / 256, 354 / 512, 651 / 1024 & $2^{60}$ \\ \hline
    \end{tabular}
    \caption{Approximate complexity to find a $\epsilon / n$-bit near collision by generic random search}
  \end{center}
\end{table}

Hill Climbing starts with a random candidate, and then choosing a random successor that has a better fit to the
solution. In practice for message M and chaining value CV $HW( h(M, CV) \oplus h(M, CV + \delta) ) = n / 2 $, can be considered
secure, where $\delta$ is n-bit vector with small Hamming weight. However, if the diffusion for the hash function h is 
not proper, then we obtain a lower Hamming weight. In such situation a correlation between two chaining values differing
in small weight $\delta$ can obtain near collisions, with hill climbing algorithm.

Here, the aim of hill climbing algorithm will be to minimize the function 

$f_{M_{1}, M_{2}}(x) = HW( h(M_{1}, x) \oplus h(M_{2}, x) )$

where $x \in \{0, 1\}^{n}$, where $M_{1}$ and $M_{2}$ are message blocks. CV is chosen as any random chaining value. Then the 
set of k-bit neighbours for the CV, will be 

$S^{k}_{CV} = \{ x \in \{0, 1\}^{n} \mid HW( CV \oplus x ) \leq k \}$

where 

$ size \thickspace of \thickspace S^{k}_{CV} = \displaystyle \sum \limits_{i = 0}^{k} \begin{pmatrix} n \\ i \end{pmatrix}$.

The k-opt condition can be defined as 

$f_{M_{1}, M_{2}} (CV) =  \min\limits_{x \in S^{k}_{CV}} f_{M_{1}, M_{2}} (x)$

We can now describe algorithm 5.1, that is used in hill climbing algorithm to find the nearest match. 

\begin{algorithm}
  \caption{ Hill Climbing algorithm ($M_{1}, M_{2}, k$) }
  \begin{algorithmic}[1]
    \State Randomly select CV
    \State $f_{best} = f_{M_{1}, M_{2}}(CV)$
    \State \While {(CV is not k-opt)}
    \State CV = x such that $x \in S^{k}_{CV}$ with $f(x) < f(best)$
    \State $f_{best} = f_{M_{1}, M_{2}}(CV)$
    \State \EndWhile
    \State \Return (CV, $f_{best}$)
  \end{algorithmic}
\end{algorithm}

Given two message $M_{1} \thickspace and \thickspace M_{2}$, and a randomly chosen chaining value CV, the $f_{M_{1}, M_{2}}(CV)$
is obtained. The set $S^{k}_{CV}$ is searched for a better fit CV, and if found is updated. And the search is repeated again
in the k-bit neighbourhood of new CV.

There are two ways of choosing the next best CV, one by choosing the first chaining value that has a lower $f$ value, the
greedy way. And another by choosing the best chaining value amongst $S^{k}_{CV}$, which is steepest ascent. The algorithm
terminates once we get k-opt chaining value.

\section{Hypothesis}

\begin{center}
  \framebox
  {
    \parbox{375pt}
    {
      \centering \textsc{Hypothesis} \\
      Reduced round Keccak, will have better resistance to near collisions found by hill climbing algorithm
      compared to BLAKE and Gr$\o$stl.
    }
  }
\end{center}

As per the \href{"http://csrc.nist.gov/groups/ST/hash/sha-3/sha-3\_selection\_announcement.pdf"}{press release from NIST}, 
one of the reasons for choosing Keccak, was that it had a large security margin. All the five finalists from SHA-3 competition
were found to be secure and have good security margins. However there has not been much study, on the comparative security
margins for the candidate's reduced versions. Hill climbing has been shown as good generic greedy algorithm to find 
near collisions for reduced versions of some SHA-3 candidates. A generic algorithm does not exploit the inner permutations
or construction, of a hash function. Rather takes a good guess approach, to what the solution can be depending on the fitness
of the candidate solution. Thus making it an ideal tool to test on any hash function, irrespective of its design.

Comparative studies on SHA-3 candidates have been using the statistical test suites provided by NIST to check any 
deficiencies \cite{00030} \cite{00032}. Other than particular attacks like zero-sum property has been tested on 
Keccak and Blue Midnight Wish \cite{00031}.

\newpage

\section{Design of the Experiment}

The hill climbing algorithm will run on the same message pairs, for all the three candidates. The chaining value for
those pairs, will be updated, but would be kept constant for the same experiment.

  \subsection{Data}
  
  For creating the message pair, I intend to choose the first message as "The quick brown fox jumps over the lazy dog.".
  The initial message contains all the letters of the English alphabet, and seems a good candidate for testing the hash.
  Another 14 messages will be created from the initial message, so in all we get $\begin{pmatrix} 15 \\ 2 \end{pmatrix}
  = 105$ pairs of message in total. The rest of the 14 messages will be derived from the first message by applying a
  shift register operation, that results in a bit flip from the previous message. For example, if my initial message has
  a bit pattern of 0000. Then the subsequent messages will be 1000, 1100, 1110 and 1111.

  This will give the experiment an advantage of comparing substantial message pairs with small to medium hamming distance.
  The initial chaining value for experiment is chosen randomly, and does not matter as long it is kept constant provided
  to all the message pairs in the experiment. Hill climbing algorithm is supposed to refine the initial chaining value,
  to the solution, which is why choice of it is not a large factor. I intend to use the hash value of empty string generated
  by Keccak as the initial chaining value for all the pairs.

  \subsection{Procedure}

  Both Keccak and Gr$\o$stl can support variable byte message digest length, but BLAKE based on SHA-2 designs can have
  message digests of 224, 256, 384 and 512 bits. Thus the experiment for 105 pairs will be done on 4 message sizes as
  indicated by BLAKE. Keccak does not have a initial state or a chaining value as such, but can be tweaked, so that it
  has the first sponge state to accept the chaining value and pre-compute it and then apply the hash function on the
  message.

  Defining the reduced rounds for each of the functions is a bit tricky. Since for each the permutation function behaves
  differently, and so arbitrarily reducing the number of rounds, for each function to a number. May not create a level
  playing field for the comparison. But, for the purposes of experiment right now, I intend to just have 2 rounds for 
  each of the candidate hash functions. The number of rounds may be tweaked as found suitable during the course of 
  experiment.
